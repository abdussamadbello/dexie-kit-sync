# 🧩 Product Requirements Document (PRD)

**Product Name:** `dexie-sync-kit`  
**Version:** v1.0 (Complete Specification)  
**Owner:** Abdussamad Bello  
**Status:** Ready for Implementation  
**Category:** Offline-first Sync SDK for Dexie.js  
**Target Users:** Frontend engineers building web/mobile PWA apps with IndexedDB (Dexie) needing background sync to REST APIs.

---

## 1. Executive Summary

**`dexie-sync-kit`** is a TypeScript-based sync framework that extends Dexie.js to handle **offline synchronization** between the browser and REST API backends—without requiring specialized database protocols like CouchDB.

It enables:

* Reliable **push/pull synchronization** with any REST API
* Configurable **per-table endpoints**, headers, and payload transforms
* Smart **outbox queue**, **checkpoints**, and **conflict resolution**
* **Leader election** for multi-tab safety and **exponential backoff** for retries
* Comprehensive **error handling** and **observability**

**Core Value Proposition:** Add robust offline sync to any web app with existing REST APIs in ~10 lines of configuration code.

---

## 2. Problem Statement

Developers using Dexie.js for offline data persistence struggle to integrate reliable synchronization with:

* **Traditional REST APIs** (no unified sync endpoint)
* **Network volatility** (offline/online transitions)
* **Data conflicts** from concurrent updates
* **Stale data** and version tracking across resources
* **Multi-tab coordination** and race conditions
* **Error recovery** and retry strategies

Existing solutions (Dexie Cloud, PouchDB, Replicache) either:

* Require specialized backend infrastructure (CouchDB, custom servers)
* Are too heavy/complex for typical REST-based apps
* Lock you into specific database systems
* Don't handle REST API patterns well

`dexie-sync-kit` provides a **standardized, minimal, extensible sync framework** that works with any REST API.

---

## 3. Goals and Non-Goals

### ✅ Goals

1. Provide **ready-to-use sync** between Dexie and any REST backend
2. Support **per-table configuration** for different endpoints or services
3. Manage **offline queue, retries, and checkpoints** transparently
4. Allow **conflict resolution strategies** (LWW, clientWins, serverWins, custom)
5. Ensure **multi-tab safety** and efficient **background sync**
6. Handle **stale data** with TTL and freshness tracking
7. Support **TypeScript-first API** with full type inference
8. Provide **comprehensive error handling** and observability
9. Work with **existing REST APIs** without backend changes

### ❌ Non-Goals

* Not a full ORM (no schema inference or relations)
* Not a backend sync protocol standard (just a client toolkit)
* Not a real-time sync layer initially (WebSockets in v2+)
* Not a CRDT engine (simple deterministic merges only)
* Not a database (relies on Dexie/IndexedDB)
* Not a server-side library (client-only)

---

## 4. Target Architecture

### 4.1 Sync Pattern: REST API (Primary)

```
┌─────────────────────────────────────────────────────────────┐
│                     dexie-sync-kit                          │
│                                                             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │ Sync Engine  │→ │  REST Adapter│→ │ HTTP Client  │     │
│  │              │  │              │  │              │     │
│  │ - Orchestrate│  │ - Map routes │  │ - Fetch API  │     │
│  │ - Queue      │  │ - Transform  │  │ - Retry      │     │
│  │ - Checkpoint │  │ - Batch      │  │ - Headers    │     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
│         ↓                                     ↓             │
│  ┌──────────────┐                    ┌──────────────┐     │
│  │   Dexie DB   │                    │   Backend    │     │
│  │  (IndexedDB) │                    │   REST API   │     │
│  └──────────────┘                    └──────────────┘     │
└─────────────────────────────────────────────────────────────┘
```

**Why REST API Pattern:**
- Works with 90% of existing web applications
- No backend changes required (mostly)
- Maximum flexibility and control
- Not locked into specific databases
- Gradual adoption possible

---

## 5. Key Features

| Category | Description |
|----------|-------------|
| **REST API Sync** | Maps to existing CRUD endpoints (GET, POST, PUT, DELETE) |
| **Outbox Queue** | Tracks offline writes and retries automatically |
| **Checkpoints** | Maintains `serverRevision` per table for delta sync |
| **Conflict Resolution** | Configurable (LWW, clientWins, serverWins, custom) |
| **Leader Election** | Ensures single-tab sync execution via `BroadcastChannel` |
| **Retry with Backoff** | Adaptive retry schedule with exponential backoff |
| **Error Taxonomy** | Clear distinction between retryable/non-retryable errors |
| **Dead Letter Queue** | Captures permanently failed items for review |
| **Staleness Tracking** | TTL-based freshness indicators per table |
| **Version Tracking** | Optional version numbers for conflict detection |
| **Rate Limiting** | Built-in rate limiter prevents API abuse |
| **Pagination Support** | Handles large datasets with cursor/offset pagination |
| **Auth Management** | Token refresh and retry on auth errors |
| **Observability** | Metrics, events, and monitoring hooks |
| **Multi-table Routing** | Different sync strategies per table |
| **TypeScript-first** | Full type inference for config and responses |

---

## 6. Architecture Overview

### 6.1 Component Diagram

```
/sync
  ├── core/
  │   ├── sync-engine.ts           # Main orchestrator
  │   ├── sync-context.ts          # Shared context/state
  │   └── types.ts                 # Core type definitions
  │
  ├── push/
  │   ├── push-processor.ts        # Push logic
  │   ├── outbox-manager.ts        # Queue management
  │   └── change-tracker.ts        # Hook into Dexie changes
  │
  ├── pull/
  │   ├── pull-processor.ts        # Pull logic
  │   ├── checkpoint-manager.ts    # Revision tracking
  │   └── change-applier.ts        # Apply server changes
  │
  ├── adapters/
  │   ├── rest-adapter.ts          # REST API mapping
  │   └── http-client.ts           # Fetch wrapper with retry
  │
  ├── conflict/
  │   ├── resolver.ts              # Conflict resolution
  │   └── strategies.ts            # LWW, clientWins, etc.
  │
  ├── utils/
  │   ├── rate-limiter.ts          # Rate limiting
  │   ├── backoff.ts               # Exponential backoff
  │   ├── leader-election.ts       # Multi-tab coordination
  │   └── metrics-collector.ts     # Observability
  │
  └── index.ts                     # Public API
```

### 6.2 Data Flow

```mermaid
flowchart TD
    A[User: Edit Data] --> B[Write to Dexie Table]
    B --> C[Dexie Hook Triggered]
    C --> D[Add to Outbox Queue]
    D --> E{Is Leader Tab?}
    E -->|No| F[Wait for Leader]
    E -->|Yes| G[Sync Engine Wakes Up]
    G --> H[Check Network Status]
    H -->|Offline| I[Schedule Retry]
    H -->|Online| J[Process Outbox]
    J --> K[Push Changes to Server]
    K --> L{Success?}
    L -->|Yes| M[Remove from Outbox]
    L -->|No| N{Retryable?}
    N -->|Yes| O[Increment Retry Count]
    N -->|No| P[Move to Dead Letter Queue]
    M --> Q[Pull New Data from Server]
    Q --> R[Check for Conflicts]
    R --> S[Apply Conflict Resolution]
    S --> T[Update Local Database]
    T --> U[Update Checkpoint]
    U --> V[Emit 'synced' Event]
    V --> W[Broadcast to Other Tabs]
    O --> I
```

---

## 7. Data Model (Dexie Schema)

### 7.1 Core Tables

| Table | Purpose | Fields |
|-------|---------|--------|
| `outbox` | Pending writes (offline-safe queue) | `++id, table, operation, key, obj, attempt, createdAt, lastError, nextRetryAt` |
| `checkpoints` | Track revision per table | `scope, revision, updatedAt` |
| `deadLetters` | Permanently failed items | `++id, table, operation, key, obj, error, failedAt, [table+key]` |
| Domain Tables | Application data | e.g., `posts`, `comments`, `users`, etc. |

### 7.2 Schema Example

```ts
db.version(1).stores({
  // Application tables
  posts: '++id, title, slug, updatedAt, version',
  comments: '++id, postId, content, updatedAt',
  users: '++id, email, name, updatedAt',
  
  // Sync metadata (auto-managed by dexie-sync-kit)
  outbox: '++id, table, operation, key, createdAt, attempt, nextRetryAt',
  checkpoints: 'scope, revision, updatedAt',
  deadLetters: '++id, table, key, failedAt, [table+key]'
});
```

### 7.3 Outbox Item Structure

```ts
interface OutboxItem {
  id: number;                    // Auto-increment
  table: string;                 // Target table name
  operation: 'create' | 'update' | 'delete';
  key: string | number;          // Primary key of record
  obj: any;                      // Full record (for create/update)
  attempt: number;               // Retry count
  createdAt: number;             // Timestamp
  lastError?: string;            // Last error message
  nextRetryAt?: number;          // When to retry next
}
```

### 7.4 Checkpoint Structure

```ts
interface Checkpoint {
  scope: string;      // 'global' | 'pull:tableName' | 'push:tableName'
  revision: string;   // Timestamp, sequential ID, or custom
  updatedAt: number;  // When checkpoint was last updated
}
```

---

## 8. API Design

### 8.1 Core API

```ts
import { startSync, defineRoutes } from 'dexie-sync-kit';
import Dexie from 'dexie';

// 1. Define database
const db = new Dexie('myapp');
db.version(1).stores({
  posts: '++id, title, updatedAt',
  comments: '++id, postId, content, updatedAt',
  // Sync tables added automatically
});

// 2. Configure routes
const routes = defineRoutes({
  posts: {
    push: {
      create: {
        method: 'POST',
        url: '/api/posts',
        body: (item) => item
      },
      update: {
        method: 'PUT',
        url: (item) => `/api/posts/${item.id}`,
        body: (item) => item
      },
      delete: {
        method: 'DELETE',
        url: (item) => `/api/posts/${item.id}`
      }
    },
    pull: {
      method: 'GET',
      url: '/api/posts',
      query: async (ctx) => ({
        updated_after: await ctx.getCheckpoint('pull:posts') || 0,
        limit: 100
      }),
      mapResponse: (response) => response.data,
      onComplete: async (response, ctx) => {
        const latest = Math.max(
          ...response.data.map(p => new Date(p.updatedAt).getTime())
        );
        await ctx.setCheckpoint('pull:posts', latest);
      }
    }
  }
});

// 3. Start sync
const syncEngine = startSync(db, {
  baseUrl: 'https://api.example.com',
  
  auth: {
    getHeaders: async () => ({
      'Authorization': `Bearer ${await getToken()}`
    }),
    onAuthError: async (error) => {
      if (error.status === 401) {
        await refreshToken();
      }
    }
  },
  
  routes,
  
  conflicts: {
    policy: 'server-wins' // or 'client-wins', 'lww', 'custom'
  },
  
  sync: {
    interval: 30000,      // Sync every 30s
    onOnline: true,       // Sync when coming online
  },
  
  staleness: {
    ttl: {
      default: 5 * 60 * 1000,    // 5 minutes
      posts: 2 * 60 * 1000        // 2 minutes for posts
    }
  }
});

// 4. Use the API
await syncEngine.start();
await syncEngine.sync();
const status = syncEngine.getStatus();
```

### 8.2 Configuration Options

```ts
interface SyncConfig {
  // Required
  baseUrl: string;
  routes: RouteConfiguration;
  
  // Authentication
  auth: {
    getHeaders: () => Promise<Record<string, string>> | Record<string, string>;
    onAuthError?: (error: AuthError) => Promise<void>;
    validateAuth?: () => Promise<boolean>;
    maxAuthRetries?: number;
  };
  
  // Sync behavior
  sync?: {
    interval?: number;              // Auto-sync interval (ms)
    onOnline?: boolean;             // Sync when online event
    onVisibilityChange?: boolean;   // Sync when tab visible
    
    push?: {
      batchSize?: number;           // Max items per batch
      concurrency?: number;         // Max concurrent requests
      debounce?: number;            // Wait after last change (ms)
    };
    
    pull?: {
      pageSize?: number;            // Items per page
      maxPages?: number;            // Max pages per sync
      pageDelay?: number;           // Delay between pages (ms)
    };
  };
  
  // Conflict resolution
  conflicts?: {
    policy: 'server-wins' | 'client-wins' | 'lww' | 'custom';
    onConflict?: (conflict: ConflictInfo) => Promise<any>;
  };
  
  // Error handling
  errors?: {
    maxRetries?: number;
    retryDelay?: (attempt: number) => number;
    onError?: (error: SyncError, context: ErrorContext) => void;
  };
  
  // Staleness tracking
  staleness?: {
    ttl?: {
      default: number;
      [table: string]: number;
    };
    onStale?: (table: string, count: number) => void;
  };
  
  // Observability
  observability?: {
    enabled?: boolean;
    metricsInterval?: number;
    onMetrics?: (metrics: SyncMetrics) => void;
  };
  
  // Advanced
  tables?: string[];                // Only sync these tables
  excludeTables?: string[];         // Exclude these tables
  revisionAdapter?: RevisionAdapter; // Custom revision handling
}
```

### 8.3 Route Configuration

```ts
interface RouteConfiguration {
  [tableName: string]: {
    push?: {
      // Option 1: Separate endpoints per operation
      create?: OperationConfig;
      update?: OperationConfig;
      delete?: OperationConfig;
      
      // Option 2: Single bulk endpoint
      url?: string;
      method?: HttpMethod;
      batch?: boolean;
      body?: (changes: Change[], ctx: SyncContext) => any;
      
      // Common options
      headers?: () => Record<string, string>;
      rateLimit?: RateLimitConfig;
    };
    
    pull?: {
      method: HttpMethod;
      url: string;
      query?: (ctx: SyncContext) => Promise<Record<string, any>>;
      mapResponse?: (response: any) => any[];
      pagination?: PaginationConfig;
      onComplete?: (response: any, ctx: SyncContext) => Promise<void>;
    };
  };
}

interface OperationConfig {
  method: HttpMethod;
  url: string | ((item: any) => string);
  body?: (item: any) => any;
  headers?: () => Record<string, string>;
}

interface PaginationConfig {
  style: 'cursor' | 'offset' | 'page';
  extractCursor?: (response: any) => string;
  hasMore: (response: any) => boolean;
}
```

### 8.4 Sync Engine API

```ts
interface SyncEngine {
  // Lifecycle
  start(): Promise<void>;
  stop(): Promise<void>;
  pause(): Promise<void>;
  resume(): Promise<void>;
  
  // Manual sync triggers
  sync(): Promise<SyncResult>;              // Push + Pull
  push(table?: string): Promise<PushResult>;
  pull(table?: string): Promise<PullResult>;
  syncTable(table: string): Promise<SyncResult>;
  
  // Status queries
  getStatus(): SyncStatus;
  isOnline(): boolean;
  isSyncing(): boolean;
  isLeader(): boolean;
  getQueueDepth(table?: string): Promise<number>;
  getMetrics(): Promise<SyncMetrics>;
  isStale(table: string, key: string): Promise<boolean>;
  
  // Table control
  pauseTable(table: string): Promise<void>;
  resumeTable(table: string): Promise<void>;
  
  // Events
  on(event: SyncEvent, handler: EventHandler): () => void;
  
  // Advanced
  healthCheck(): Promise<HealthCheckResult>;
  getDeadLetters(table?: string): Promise<DeadLetterItem[]>;
  retryDeadLetter(id: number): Promise<void>;
}
```

### 8.5 Events

```ts
type SyncEvent =
  | 'sync-start'
  | 'sync-complete'
  | 'sync-error'
  | 'push-start'
  | 'push-complete'
  | 'push-error'
  | 'pull-start'
  | 'pull-complete'
  | 'pull-error'
  | 'conflict'
  | 'online'
  | 'offline'
  | 'stale'
  | 'metrics';

// Usage
syncEngine.on('sync-complete', (result) => {
  console.log('Sync completed:', result);
});

syncEngine.on('conflict', (conflict) => {
  showConflictDialog(conflict);
});

syncEngine.on('metrics', (metrics) => {
  sendToMonitoring(metrics);
});
```

---

## 9. Error Handling

### 9.1 Error Taxonomy

```ts
type SyncError = 
  // Network errors (retryable)
  | { 
      type: 'network',
      code: 'FETCH_FAILED' | 'TIMEOUT' | 'CORS' | 'DNS_ERROR',
      retryable: true,
      retryAfter?: number
    }
  
  // Auth errors (need user action)
  | {
      type: 'auth',
      code: 'UNAUTHORIZED' | 'FORBIDDEN' | 'TOKEN_EXPIRED',
      retryable: false,
      requiresUserAction: true
    }
  
  // Validation errors (non-retryable)
  | {
      type: 'validation',
      code: 'INVALID_DATA' | 'MISSING_REQUIRED_FIELD' | 'CONSTRAINT_VIOLATION',
      retryable: false,
      field?: string,
      details: Record<string, string[]>
    }
  
  // Conflict errors (retryable with resolution)
  | {
      type: 'conflict',
      code: 'VERSION_MISMATCH' | 'CONCURRENT_MODIFICATION',
      retryable: true,
      localValue: unknown,
      remoteValue: unknown,
      resolution: 'manual' | 'auto'
    }
  
  // Quota/rate limit errors (retryable with delay)
  | {
      type: 'quota',
      code: 'RATE_LIMIT' | 'STORAGE_QUOTA' | 'REQUEST_TOO_LARGE',
      retryable: true,
      retryAfter: number
    }
  
  // Server errors (retryable)
  | {
      type: 'server',
      code: 'INTERNAL_ERROR' | 'SERVICE_UNAVAILABLE' | 'MAINTENANCE',
      retryable: true,
      status: number
    }
  
  // Client errors (non-retryable)
  | {
      type: 'client',
      code: 'INVALID_CONFIG' | 'SCHEMA_MISMATCH' | 'UNSUPPORTED_OPERATION',
      retryable: false,
      message: string
    };
```

### 9.2 Retry Strategy

```ts
// Default retry configuration
const DEFAULT_RETRY_CONFIG = {
  maxRetries: 5,
  retryDelay: (attempt: number) => {
    // Exponential backoff: 1s, 2s, 4s, 8s, 16s, max 60s
    return Math.min(1000 * Math.pow(2, attempt), 60000);
  },
  maxRetries: {
    network: 5,
    server: 3,
    conflict: 3,
    default: 1
  }
};
```

### 9.3 Dead Letter Queue

Items that cannot be synced after max retries are moved to the dead letter queue for manual review:

```ts
interface DeadLetterItem {
  id: number;
  table: string;
  operation: 'create' | 'update' | 'delete';
  key: string | number;
  obj: any;
  error: string;
  errorType: string;
  failedAt: number;
  originalAttempts: number;
}

// API to manage dead letters
const deadLetters = await syncEngine.getDeadLetters();
await syncEngine.retryDeadLetter(deadLetterId);
await syncEngine.deleteDeadLetter(deadLetterId);
```

---

## 10. Conflict Resolution

### 10.1 Built-in Strategies

```ts
type ConflictPolicy = 
  | 'server-wins'   // Always use server version (safest)
  | 'client-wins'   // Always use client version (risky)
  | 'lww'           // Last-write-wins based on timestamp
  | 'custom';       // Developer-defined merge function

// Configuration
startSync(db, {
  conflicts: {
    policy: 'lww',
    
    // Optional: Custom resolver
    onConflict: async (conflict) => {
      const { table, key, local, remote } = conflict;
      
      // Custom merge logic
      return {
        ...remote,
        title: local.title, // Keep local title
        content: remote.content // Use server content
      };
    }
  }
});
```

### 10.2 Conflict Detection

Conflicts are detected when:
1. Local has pending changes in outbox
2. Server returns different version during pull
3. Version numbers mismatch (if using version tracking)

### 10.3 Conflict Information

```ts
interface ConflictInfo {
  table: string;
  key: string | number;
  local: any;           // Local version
  remote: any;          // Server version
  localTimestamp: number;
  remoteTimestamp: number;
  localVersion?: number;
  remoteVersion?: number;
}
```

---

## 11. Staleness Management

### 11.1 TTL Configuration

```ts
startSync(db, {
  staleness: {
    ttl: {
      default: 5 * 60 * 1000,      // 5 minutes default
      posts: 2 * 60 * 1000,         // 2 minutes for posts
      comments: 1 * 60 * 1000,      // 1 minute for comments
      users: 30 * 60 * 1000,        // 30 minutes for users
    },
    
    staleWhileRevalidate: true,    // Show stale, fetch in background
    
    onStale: (table, count) => {
      console.log(`${count} ${table} records are stale`);
      showStalenessIndicator(table);
    }
  }
});
```

### 11.2 Staleness API

```ts
// Check if specific record is stale
const isStale = await syncEngine.isStale('posts', postId);

// Get staleness age
const age = await syncEngine.getStaleness('posts', postId); // Returns ms

// Force refresh
await syncEngine.refresh('posts', postId);

// Get metadata
const meta = await syncEngine.getMeta('posts', postId);
// { fetchedAt: 1234567890, age: 120000, isStale: true }
```

### 11.3 UI Integration

```tsx
function PostsList() {
  const { posts, lastSynced, isSyncing } = useSyncState('posts');
  
  return (
    <div>
      <StalenessIndicator 
        lastSynced={lastSynced}
        isSyncing={isSyncing}
      />
      {posts.map(post => (
        <PostItem 
          key={post.id} 
          post={post}
          isStale={isOlderThan(post.updatedAt, lastSynced)}
        />
      ))}
    </div>
  );
}
```

---

## 12. Authentication

### 12.1 Auth Configuration

```ts
startSync(db, {
  auth: {
    // Get current auth headers
    getHeaders: async () => {
      const token = await getAccessToken();
      return {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      };
    },
    
    // Handle auth errors
    onAuthError: async (error) => {
      if (error.status === 401) {
        await refreshAccessToken();
      } else if (error.status === 403) {
        syncEngine.pause();
        showPermissionError();
      }
    },
    
    // Validate before sync
    validateAuth: async () => {
      const token = await getAccessToken();
      return token && !isTokenExpired(token);
    },
    
    maxAuthRetries: 3
  }
});
```

### 12.2 Token Refresh Flow

```
1. Sync attempts request
2. Token expired (401)
3. onAuthError called
4. Refresh token
5. Retry request with new token
6. If still fails after maxAuthRetries, pause sync
```

---

## 13. Observability

### 13.1 Metrics

```ts
interface SyncMetrics {
  // Queue metrics
  queue: {
    depth: number;              // Items in outbox
    oldestItemAge: number;      // Ms since oldest item
    avgProcessingTime: number;  // Avg sync time per item
  };
  
  // Sync performance
  sync: {
    lastSyncStarted: number;
    lastSyncCompleted: number;
    lastSyncDuration: number;
    syncCount: number;
    pushCount: number;
    pullCount: number;
  };
  
  // Error tracking
  errors: {
    total: number;
    byType: Record<string, number>;
    failedRetries: number;
    deadLetterCount: number;
  };
  
  // Network
  network: {
    requestCount: number;
    bytesUploaded: number;
    bytesDownloaded: number;
    avgLatency: number;
  };
  
  // Data stats
  data: {
    totalRecords: number;
    byTable: Record<string, number>;
    diskUsage?: number;
  };
}
```

### 13.2 Metrics API

```ts
// Get current metrics
const metrics = await syncEngine.getMetrics();

// Subscribe to periodic updates
syncEngine.on('metrics', (metrics) => {
  sendToDatadog(metrics);
});

// Configure metrics
startSync(db, {
  observability: {
    enabled: true,
    metricsInterval: 30000, // Every 30s
    enableTracing: true,
    enablePerformanceMarks: true
  }
});
```

### 13.3 Health Check

```ts
const health = await syncEngine.healthCheck();

// Returns:
{
  healthy: boolean;
  issues: Array<{
    severity: 'warning' | 'error';
    message: string;
    code: string;
  }>;
  metrics: {
    queueDepth: number;
    lastSync: number;
    errorRate: number;
  };
}
```

---

## 14. Multi-Tab Coordination

### 14.1 Leader Election

Uses `BroadcastChannel` API to elect a single leader tab:

```ts
// Only the leader performs sync
// Other tabs listen for updates

class LeaderElection {
  private channel: BroadcastChannel;
  private isLeader = false;
  
  async electLeader() {
    // Simple timestamp-based election
    this.channel.postMessage({ type: 'election', timestamp: Date.now() });
    
    // Lowest timestamp wins
    setTimeout(() => {
      this.isLeader = true;
      this.channel.postMessage({ type: 'leader', tabId: this.id });
    }, 100);
  }
}
```

### 14.2 Cross-Tab Communication

```ts
// Leader broadcasts sync events
channel.postMessage({ 
  type: 'sync-complete', 
  tables: ['posts'], 
  timestamp: Date.now() 
});

// Other tabs update UI
channel.onmessage = (event) => {
  if (event.data.type === 'sync-complete') {
    refreshUI(event.data.tables);
  }
};
```

---

## 15. Performance Targets

| Metric | Target | Measurement |
|--------|--------|-------------|
| Sync latency | <100ms per batch locally | Time from trigger to completion |
| Max batch size | 1000 changes | Configurable per table |
| Max retry interval | 60s | Exponential backoff ceiling |
| Lost change probability | 0% | Dead letter queue captures all |
| Tab concurrency | N tabs, 1 leader | No duplicate syncs |
| Bundle size | <20 KB gzipped | Tree-shakeable exports |
| Memory overhead | <5MB for 10k records | IndexedDB + outbox |
| Sync success rate | >99.9% | With retry logic |
| Battery impact | Minimal | Batch operations, backoff |

---

## 16. Backend Requirements

### 16.1 Minimal Requirements

Your backend needs:

1. **REST endpoints** for CRUD operations
2. **Timestamp field** (e.g., `updatedAt`) for delta queries
3. **Query filtering** by timestamp (e.g., `?updated_after=1234567890`)
4. **Standard HTTP status codes** (401, 404, 409, etc.)

### 16.2 Recommended Features

For optimal sync:

1. **Version numbers** or ETags for conflict detection
2. **Bulk endpoints** for batch operations
3. **Pagination** for large datasets
4. **Proper error responses** with retryable flag

### 16.3 Backend Examples

See Section 17 for complete backend implementations in:
- Express.js (Node.js)
- FastAPI (Python)
- Rails (Ruby)
- Laravel (PHP)

---

## 17. Backend Implementation Guide

### 17.1 Express.js (Node.js)

```ts
import express from 'express';
import { PrismaClient } from '@prisma/client';

const app = express();
const db = new PrismaClient();

app.use(express.json());

// Pull endpoint - GET /api/posts
app.get('/api/posts', async (req, res) => {
  const { updated_after = '0', limit = '100' } = req.query;
  
  const posts = await db.post.findMany({
    where: {
      updatedAt: {
        gt: new Date(Number(updated_after))
      }
    },
    orderBy: { updatedAt: 'asc' },
    take: Number(limit)
  });
  
  res.json({
    data: posts,
    hasMore: posts.length === Number(limit)
  });
});

// Create endpoint - POST /api/posts
app.post('/api/posts', async (req, res) => {
  try {
    const post = await db.post.create({
      data: {
        ...req.body,
        updatedAt: new Date()
      }
    });
    res.status(201).json(post);
  } catch (error) {
    if (error.code === 'P2002') {
      res.status(409).json({ error: 'Duplicate', retryable: false });
    } else {
      res.status(400).json({ error: error.message, retryable: false });
    }
  }
});

// Update endpoint - PUT /api/posts/:id
app.put('/api/posts/:id', async (req, res) => {
  const { expectedVersion, ...data } = req.body;
  
  const current = await db.post.findUnique({ where: { id: req.params.id } });
  
  if (!current) {
    return res.status(404).json({ error: 'Not found', retryable: false });
  }
  
  if (expectedVersion && current.version !== expectedVersion) {
    return res.status(409).json({
      error: 'Version conflict',
      serverVersion: current.version,
      serverData: current,
      retryable: false
    });
  }
  
  const updated = await db.post.update({
    where: { id: req.params.id },
    data: {
      ...data,
      version: current.version + 1,
      updatedAt: new Date()
    }
  });
  
  res.json(updated);
});

// Delete endpoint - DELETE /api/posts/:id
app.delete('/api/posts/:id', async (req, res) => {
  try {
    await db.post.delete({ where: { id: req.params.id } });
    res.status(204).send();
  } catch (error) {
    if (error.code === 'P2025') {
      // Already deleted
      res.status(204).send();
    } else {
      res.status(500).json({ error: error.message, retryable: true });
    }
  }
});

app.listen(3000);
```

### 17.2 FastAPI (Python)

```python
from fastapi import FastAPI, HTTPException, Query
from datetime import datetime
from pydantic import BaseModel
from typing import Optional

app = FastAPI()

class Post(BaseModel):
    id: Optional[str] = None
    title: str
    content: str
    updatedAt: datetime
    version: int = 1

@app.get("/api/posts")
async def pull_posts(
    updated_after: int = Query(0),
    limit: int = Query(100)
):
    posts = await db.posts.find({
        "updatedAt": {"$gt": datetime.fromtimestamp(updated_after / 1000)}
    }).sort("updatedAt", 1).limit(limit).to_list()
    
    return {
        "data": posts,
        "hasMore": len(posts) == limit
    }

@app.post("/api/posts", status_code=201)
async def create_post(post: Post):
    post.updatedAt = datetime.now()
    result = await db.posts.insert_one(post.dict())
    post.id = str(result.inserted_id)
    return post

@app.put("/api/posts/{post_id}")
async def update_post(post_id: str, post: Post):
    current = await db.posts.find_one({"id": post_id})
    
    if not current:
        raise HTTPException(404, {"error": "Not found", "retryable": False})
    
    if hasattr(post, 'expectedVersion') and \
       current['version'] != post.expectedVersion:
        raise HTTPException(409, {
            "error": "Version conflict",
            "serverVersion": current['version'],
            "serverData": current
        })
    
    post.version = current['version'] + 1
    post.updatedAt = datetime.now()
    
    await db.posts.update_one({"id": post_id}, {"$set": post.dict()})
    return post

@app.delete("/api/posts/{post_id}", status_code=204)
async def delete_post(post_id: str):
    await db.posts.delete_one({"id": post_id})
    return None
```

---

## 18. Testing Strategy

### 18.1 Test Coverage

| Category | Test Type | Coverage |
|----------|-----------|----------|
| Unit Tests | Core logic | 90%+ |
| Integration Tests | Full sync flow | 80%+ |
| E2E Tests | Multi-tab, offline | Key scenarios |
| Performance Tests | Load, stress | Benchmarks |

### 18.2 Key Test Scenarios

**Unit Tests:**
- Outbox queue operations
- Checkpoint management
- Conflict resolution algorithms
- Retry backoff calculation
- Rate limiting logic

**Integration Tests:**
- Push creates/updates/deletes
- Pull with pagination
- Conflict detection and resolution
- Error handling and retry
- Dead letter queue
- Auth token refresh

**E2E Tests (Playwright):**
- Multi-tab leader election
- Network interruption and recovery
- Concurrent edits in multiple tabs
- Large dataset sync
- Clock skew scenarios
- Schema migrations

### 18.3 Test Example

```ts
describe('dexie-sync-kit', () => {
  let db, syncEngine, mockServer;
  
  beforeEach(async () => {
    db = await setupTestDB();
    mockServer = await startMockServer();
    syncEngine = startSync(db, testConfig);
  });
  
  it('pushes creates to server', async () => {
    await db.posts.add({ title: 'Test Post' });
    await syncEngine.push();
    
    const serverPosts = await mockServer.getPosts();
    expect(serverPosts).toHaveLength(1);
    expect(serverPosts[0].title).toBe('Test Post');
    
    const outbox = await db.outbox.toArray();
    expect(outbox).toHaveLength(0);
  });
  
  it('handles version conflicts', async () => {
    await db.posts.put({ id: '1', title: 'Local', version: 1 });
    await mockServer.createPost({ id: '1', title: 'Server', version: 2 });
    
    await syncEngine.sync();
    
    const post = await db.posts.get('1');
    expect(post.title).toBe('Server'); // Server wins
  });
  
  it('retries on network failure', async () => {
    mockServer.simulateNetworkError();
    
    await db.posts.add({ title: 'Test' });
    await syncEngine.push();
    
    let outbox = await db.outbox.toArray();
    expect(outbox[0].attempt).toBe(1);
    
    mockServer.restoreNetwork();
    await syncEngine.push();
    
    outbox = await db.outbox.toArray();
    expect(outbox).toHaveLength(0);
  });
});
```

---

## 19. Migration & Schema Changes

### 19.1 Strategy

**V1 Approach: Simple & Pragmatic**

For MVP, use additive-only schema changes:
- ✅ Add new fields (always safe)
- ❌ Avoid renaming/removing fields
- ✅ Clear and resync for breaking changes

```ts
// Safe migration (additive)
db.version(1).stores({
  posts: '++id, title, createdAt'
});

db.version(2).stores({
  posts: '++id, title, slug, createdAt' // Added slug
});

// Breaking change - clear and resync
if (schemaVersionChanged) {
  await db.delete();
  await db.open();
  await syncEngine.fullResync();
}
```

### 19.2 Future Enhancement (V2+)

Add migration API for complex scenarios:

```ts
const migrations = [
  {
    version: 3,
    description: 'Rename heading → title',
    migrate: async (db) => {
      const posts = await db.posts.toArray();
      for (const post of posts) {
        if ('heading' in post) {
          post.title = post.heading;
          delete post.heading;
          await db.posts.put(post);
        }
      }
    },
    sync: {
      pauseDuring: true,
      clearCheckpoints: ['posts']
    }
  }
];
```

---

## 20. Security Considerations

### 20.1 Client-Side Security

- **Never store sensitive tokens** in IndexedDB (use httpOnly cookies)
- **Validate data** before sync (prevent XSS)
- **Use HTTPS** for all API calls
- **Implement CSP** headers
- **Rate limit** client-side requests

### 20.2 Server-Side Requirements

- **Authenticate** all sync endpoints
- **Authorize** data access per user
- **Validate** all incoming data
- **Rate limit** per user/IP
- **Log** sync operations for audit

### 20.3 Best Practices

```ts
// Good: Token in memory or secure storage
auth: {
  getHeaders: async () => ({
    'Authorization': `Bearer ${await getSecureToken()}`
  })
}

// Bad: Token in IndexedDB
// Don't do this:
await db.config.put({ token: 'abc123' });
```

---

## 21. Roadmap

| Version | Milestone | Features | Timeline |
|---------|-----------|----------|----------|
| **v0.1** | MVP | Core sync, outbox, checkpoints, REST adapter | Month 1-2 |
| **v0.2** | Error Handling | Retry logic, dead letters, error taxonomy | Month 2 |
| **v0.3** | Conflicts | LWW, version tracking, conflict UI | Month 3 |
| **v0.4** | Observability | Metrics, events, monitoring hooks | Month 3 |
| **v0.5** | Polish | TTL, staleness, rate limiting | Month 4 |
| **v0.9** | Beta | Full testing, docs, demo apps | Month 5 |
| **v1.0** | Stable Release | Production-ready, comprehensive docs | Month 6 |
| **v1.1+** | Enhancements | WebSocket plugin, CRDT plugin, Service Worker | Month 7+ |

---

## 22. Success Metrics

| Metric | Target | Measurement Method |
|--------|--------|-------------------|
| Developer adoption | 50+ apps in 3 months | NPM downloads, GitHub stars |
| Sync reliability | 99.9% success rate | Telemetry from observability |
| Bundle size | <20 KB gzipped | Build analysis |
| Setup time | <30 minutes | Documentation feedback |
| Mobile support | 100% PWA compatible | Testing on iOS/Android |
| Developer satisfaction | ≥9/10 DX score | Survey after 1 month usage |
| Performance | <100ms sync latency | Benchmark tests |
| Error recovery | 0% data loss | Integration tests |

---

## 23. Deliverables

| Deliverable | Description | Format |
|-------------|-------------|--------|
| **Core Package** | `dexie-sync-kit` NPM package | TypeScript, ESM |
| **Type Definitions** | Full TypeScript types | `.d.ts` files |
| **Documentation Site** | Complete guides and API reference | Docusaurus/VitePress |
| **Demo App** | React app with offline sync | GitHub repo |
| **Backend Examples** | Express, FastAPI, Rails, Laravel | GitHub repos |
| **Integration Tests** | Full test suite | Vitest + Playwright |
| **Migration Guide** | Adding sync to existing apps | Markdown doc |
| **Performance Benchmarks** | Load test results | Public dashboard |
| **CLI Tools** | Debugging and introspection | NPM package |

---

## 24. Developer Experience Goals

### 24.1 Setup Experience

```bash
# Install
npm install dexie-sync-kit

# Configure (10 lines)
import { startSync } from 'dexie-sync-kit';
const syncEngine = startSync(db, { /* minimal config */ });

# Done! Sync works automatically
```

### 24.2 TypeScript Experience

```ts
// Full type inference
const routes = defineRoutes({
  posts: {
    pull: {
      mapResponse: (response) => response.data
      //           ^^^^^^^^^^ type: any (infers from response)
    }
  }
});

// Type-safe API
const result = await syncEngine.sync();
//    ^^^^^^ type: SyncResult with all fields
```

### 24.3 Debugging Experience

```ts
// Rich console logs in dev
syncEngine.on('push-start', () => {
  console.log('[Sync] Starting push...');
});

// Built-in devtools
window.__DEXIE_SYNC_DEVTOOLS__ = syncEngine;

// CLI tool
npx dexie-sync inspect
// Shows: queue depth, last sync, errors, checkpoints
```

---

## 25. Comparison with Alternatives

| Feature | dexie-sync-kit | Dexie Cloud | PouchDB | Replicache | Firebase |
|---------|----------------|-------------|---------|------------|----------|
| **Works with REST APIs** | ✅ | ❌ | ❌ | ❌ | ❌ |
| **No backend changes** | ✅ (mostly) | ❌ | ❌ | ❌ | ❌ |
| **Offline-first** | ✅ | ✅ | ✅ | ✅ | ✅ |
| **Conflict resolution** | ✅ | ✅ | ✅ | ✅ | ✅ |
| **Multi-tab safe** | ✅ | ✅ | ✅ | ✅ | ✅ |
| **Bundle size** | ~20KB | ~50KB | ~150KB | ~80KB | ~300KB |
| **Backend agnostic** | ✅ | ❌ | ❌ | ❌ | ❌ |
| **TypeScript-first** | ✅ | ✅ | ❌ | ✅ | ✅ |
| **Self-hosted** | ✅ | ❌ | ✅ | ❌ | ❌ |
| **Free tier** | ✅ | Limited | ✅ | Limited | Limited |
| **Real-time sync** | Plugin (v2) | ✅ | ✅ | ✅ | ✅ |

---

## 26. Open Questions & Future Research

1. **Service Worker Integration** - Should sync run in SW for background sync?
2. **Partial Sync** - Sync only specific fields, not entire records?
3. **Schema Versioning** - Auto-detect and migrate schema changes?
4. **Compression** - Compress payloads for large syncs?
5. **Encryption** - E2E encryption layer for sensitive data?
6. **Collaborative Editing** - CRDT plugin architecture?
7. **Analytics** - Built-in analytics for sync patterns?
8. **Multi-device Sync** - Cross-device coordination?

---

## 27. Appendix A: Glossary

| Term | Definition |
|------|------------|
| **Checkpoint** | Revision marker for delta sync (timestamp/version) |
| **Outbox** | Queue of pending changes waiting to sync |
| **Dead Letter Queue** | Failed items after max retries |
| **LWW** | Last-Write-Wins conflict resolution |
| **TTL** | Time-To-Live for cache freshness |
| **CRDT** | Conflict-free Replicated Data Type |
| **OT** | Operational Transform |
| **Delta Sync** | Sync only changes since last checkpoint |
| **Leader Tab** | Tab responsible for sync coordination |
| **Staleness** | Age of cached data |

---

## 28. Appendix B: References

**Academic & Research:**
- [Local-first Software](https://www.inkandswitch.com/local-first/) - Martin Kleppmann
- [CRDTs: Consistency without concurrency control](https://arxiv.org/abs/0907.0929)

**Technical Documentation:**
- [Dexie.js Documentation](https://dexie.org/)
- [IndexedDB API](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API)
- [Service Worker API](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API)

**Industry Examples:**
- [How Figma's multiplayer technology works](https://www.figma.com/blog/how-figmas-multiplayer-technology-works/)
- [Notion's data model](https://www.notion.so/blog/data-model-behind-notion)
- [Linear's sync engine](https://linear.app/blog/scaling-the-linear-sync-engine)

---

## 29. Sign-off

This PRD represents the complete specification for `dexie-sync-kit` v1.0. 

**Approved by:**
- Product: [Name]
- Engineering: [Name]
- Design: [Name]

**Next Steps:**
1. Engineering review and estimation
2. Architecture design doc
3. Implementation kickoff
4. Alpha release planning

**Document History:**
- v1.0 - 2025-01-25 - Initial complete specification
- v0.9 - 2025-01-24 - Added REST API pattern details
- v0.8 - 2025-01-23 - Added error handling and staleness sections
- v0.1 - 2025-01-20 - Initial draft

---

**End of PRD**

---

*This document is comprehensive and ready for implementation. All major technical decisions have been made, edge cases considered, and APIs designed. The implementation can begin immediately with this specification.*
